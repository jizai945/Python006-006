# WEEK05 中间件



## 为什么使用中间件 & 缓存的类别

用户量增加之后，单体没办法抗住比较大的用户请求

最常用的中间件就是缓存和消息队列

*企业级应用为什么需要缓存和消息队列?*

+   随着业务规模扩大，单体应用不再满足业务场景需求
+   用户数量剧增，单凭数据库无法抗住并发压力 (消息队列/MQTT)
+   业务场景复杂需要解耦
+   业务场景丰富造成访问热点(通过缓存机制降低数据库压力)



缓存通常工作在内存中，mysql一般放在磁盘里

缓存的分类：

+   本地缓存
+   分布式缓存

差异：调用方式、开销

**本地缓存的特点**：效率高，空间大小和本地内存大小有关，一般空间较小，一般放静态数据，配置文件或者配置数据

**分布式的缓存的特点**：要有网络的开销，空间较大，一般全局数据，多个业务模块之间共享的



## 缓存的同步方式有哪些



缓存

![](./cache_and_db.png)



应用程序和缓存/数据库

1.  Cache Aside: 用户请求数据：先判断缓存中是否有数据，有则返回用户，没有则从数据库中读取出来，保存到缓存并返回给用户。

​					用户更新数据: 更新数据库，然后对缓存做一个更新

​	优点：实现简单

​	缺点： 对后台业务代码有侵入，必须知道数据缓存结构。

2.  Write Through 对于应用程序认为只有数据库, 做一层封装，把缓存和数据库的处理通过类似ORM的方式封装起来，对于应用程序就是一体。

    优点：不需要管是否有缓存

    缺点：缓存和数据的逻辑需要自己去维护

3.   Write Back 对于应用程序认为只有缓存。 应用程序只修改缓存，对于数据库不去管。需要自己做一个消息队列，当有缓存数据后，通过消息队列同步到数据库。

    优点：访问和返回的速度快

    缺点：异步读写容易出现数据丢失的风险，一致性容易出问题



缓存与数据库之间的同步的方式

1.  双写：好处：简单 ,延迟低速度快坏处：容易造成数据不同步,耦合度最高

    解决不同步问题：引入==分布式事务==  ，定时通过读数据库同步缓存的数据

2.  消息队列方式：相对于双写效率低一些， 可以解决并发问题

3.  MySQL binlog: 使用MySQL binglog 重放同步到 Redis，延迟最高, 耦合度最低



| 方式         | 延迟性 | 耦合度 | 复杂度 |
| ------------ | ------ | ------ | ------ |
| 双写         | 最低   | 最高   | 最低   |
| 消息队列方式 | 居中   | 居中   | 居中   |
| MySQL binlog | 最高   | 最低   | 最高   |



## 缓存有可能出现的问题



架构中使用缓存有可能带来的问题？

+   缓存穿透  （查询一个不存在的值, 导致每次都要从数据库中查询）
+   缓存并发    可以使用互斥锁的方法解决
+   缓存雪崩    （同一时间缓存的key过期）缓存的时间上加上一点随机时间或者多级缓存

 

## 安装Redis、连接Redis

Redis的特点:

+   使用IO多路复用机制
+   监听多个文件描述符实现读写事件
+   单工作线程(6.0以前)

注意：单工作线程可能会导致多个会话会相互干扰



Redis的对象类型

+   字符串
+   列表
+   哈希
+   集合
+   有序集合



目前比较稳定版本：redis-6.0.9.tar.gz

